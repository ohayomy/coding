비트연산자
~	비트의 반전(1의보수)	a= ~a;
&	비트 단위 AND		 1&1만 1반환 그외에는 0
|	비트 단위 OR		0|0만 0반환 그 외에는 1
^	비트 단위 XOR		두개의 비트가 서로 다른 경우에 1을 반환
<<	왼쪽 shift			a<<2 라 치면 변수a를 2비트만큼 왼쪽으로 이동
>>	오른쪽 shift		a>>2 라고 하면 변수 a를 2비트만큼 오른쪽으로 이동
>>>	오른쪽 shift		>> 동일한 연산. 채워지는 비트가 부호와 상관없이 0임

비트를 왼쪽으로 밀면 뒤는 0으로 채워지는게 기본이고, 오른쪽으로 밀면 앞의 부호비트가 0인 경우엔 0으로
1인 경우엔 1로 채워진다. 왜냐하면 부호비트가 1일경우 음수라서 표기방식 자체가 반대이기 때문에 1이 0의 역할을 하기 때문이다. 그러나 >>>3개로 오른쪽이동하면 그걸 고려하지 않고 0으로 채운다.

비트연산자의 경우도 ~=, &=, <<=, >>>= 등등 계산하고 대입하는 단항연산자 방식으로 사용할 수 있다.
ex) num <<= 2 , num &= 15, etc...



보수란 보충하는 수
보수란 보충하는 수라는 뜻으로
기본적인 계산은 십진수일 때, 4의 보수는 6이고 12의 보수는 100- 12를 해서 88이다.
10을 기준으로 1, 10 ,100, 1000 단위로 보수를 계산한다.
즉 , 보수란 진법의 자리표기를 위주로 고안됐으며, 컴퓨터를 위한 개념이다.
예컨데 컴퓨터 내부에서는 A - B를 계산할 때 B의 보수(-B)를 구한 다음 A + (-B)로 계산한다.
1의 보수라는 것은 편의를 위해 정의한 것이고, 실질적인 보수는 2의 보수이다.
쉽게 십진법으로 보면, 
55 - 24 = 31 에서 24의 1의보수가 76이 되는것이고
55 + 76 = 131 에서 1을 빼고 31만 계산하는 식이다.
55 - 79 = -26 같이 자리수가 변하는 경우는 100을 더해서
55 + 21 = 76
111(2) - 110(2) = 